//
//  HexViewDrawNote.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#include "pch.h"
#include "HexView.h"
#include "HexViewInternal.h"

#define SHADOW_DEPTH 2

/* Generated by HexEdit */
/* C:\src\Hex\HexEdit\icon2.ico */
BYTE HexData4[64] =
{
  0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 
  0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xfd, 0x00, 0x00, 
  0xff, 0xfb, 0x00, 0x00, 0xff, 0xf5, 0x00, 0x00, 0xff, 0xeb, 0x00, 0x00, 0xff, 0xd5, 0x00, 0x00, 
  0xff, 0xab, 0x00, 0x00, 0xff, 0x55, 0x00, 0x00, 0xfe, 0xab, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00
};

/* Generated by HexEdit */
/* C:\src\Hex\HexEdit\icon2.ico */
WORD HexData1[32] =
{
  0xffff,  0xffff, 0xffff, 0xffff, 
  0xffff,  0xffff, 0xffff, 0xfdff, 
  0xfbff,  0xf5ff, 0xebff, 0xd5ff, 
  0xabff,  0x55ff, 0xabfe, 0xffff, 
};

/* Generated by HexEdit */
/* C:\src\Hex\HexEdit\icon3.ico */
BYTE HexData2[] =
{
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  0xff, 0xff,  
  0xff, 0xff, 0xff, 0xff, 0xe7, 0x3f,  0xe2, 0x3f,  
  0xf0, 0x7f, 0xf8, 0xff, 0xf0, 0x7f,  0xe2, 0x3f,  
  0xe7, 0x3f, 0xff, 0xff, 0xff, 0xff,  0xff, 0xff
};

/* [x] close button with border */
WORD CloseButtonBitmapData[32] =
{
  0xffff, 0xffff, 0xffff, 0x0700,  
  0x0700, 0xe73f, 0x2727, 0x2722,  
  0x6730, 0xe738, 0x6730, 0x2722,  
  0x2727, 0xe73f, 0x0700, 0x0700
};


/* Generated by HexEdit */
/* C:\src\HexEdit2\HexEdit\ico00001.ico */
WORD CloseButtonDown[32] = 
{
  0xFFFF, 0xFFFF, 0xFFFF, 0x0700, 
  0x0700, 0x0700, 0xC718, 0xC71D, 
  0x870F, 0x0707, 0x870F, 0xC71D, 
  0xC718, 0x0700, 0x0700, 0x0700, 
};


/*
void RoundRect0(HDC hdc, int x1, int y1, int x2, int y2)
{
	MoveToEx(hdc, x1+1, y1, 0);
	LineTo(hdc, x2-1, y1);
	SetPixel(hdc, x1+1, y1+1, 0);

	MoveToEx(hdc, x2, y1+1, 0);
	LineTo(hdc, x2, y2-1);
	SetPixel(hdc, x2-1, y1+1, 0);

	MoveToEx(hdc, x2-1, y2, 0);
	LineTo(hdc, x1+1, y2);
	SetPixel(hdc, x2-1, y2-1, 0);

	MoveToEx(hdc, x1, y2-1, 0);
	LineTo(hdc, x1, y1+1);
	SetPixel(hdc, x1+1, y2-2, 0);
}
*/

void SizingGrip(HDC hdc, RECT *rect, HPEN hPen)
{
	const int grip_size = BOOKMARK_GRIPWIDTH;
	RECT r = { rect->right - 3 - grip_size, rect->bottom - 3 - grip_size, rect->right - 3, rect->bottom - 3 };
	//SetBkColor(hdc, 0);
	POINT pt1 = { rect->right - 4, rect->bottom - 3 };
	POINT pt2 = { rect->right - 3, rect->bottom - 4 };
	
	int x = rect->right - 3, y = rect->bottom - 3;
	//SelectObject(hdc, hPen);
	for(int i = 0; i < 4; i++)
	{
		MoveToEx(hdc, pt1.x, pt1.y, 0);
		LineTo(hdc, pt2.x+1, pt2.y-1 );

		pt1.x -= 2;
		pt2.y -= 2;
	}

}

void CloseButton(HDC hdc, RECT *rect, RECT *out, BOOL fHover)
{
	if(out)
	{
		out->left   = rect->right - 16;
		out->top    = rect->top + 4;
		out->right  = out->left + 13;
		out->bottom = out->top + 13;//16;
	}

	if(hdc)
	{
		BOOL fDown = fHover && (GetKeyState(VK_LBUTTON) & 0x80000000);

		HDC     hdcMem  = CreateCompatibleDC(hdc);
		HBITMAP hBmp = CreateBitmap(16, 16, 1, 1, fDown ? CloseButtonDown : CloseButtonBitmapData);
		HANDLE  hOld = SelectObject(hdcMem, hBmp);

		TRACEA("hot: %d\n", fHover);


		if(fDown)
		{
			SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
		}
		else if(fHover)
		{
			SetTextColor(hdc, GetSysColor(COLOR_3DDKSHADOW));
		}
		else
		{
			SetTextColor(hdc, GetSysColor(COLOR_3DSHADOW));
		}

		//SetBkColor(hdc, colBG);
		BitBlt(hdc, rect->right - 16, rect->top + 1, 13, 16, hdcMem, 0, 0, SRCCOPY);

		SelectObject(hdcMem, hOld);
		DeleteObject(hBmp);
		DeleteDC(hdcMem);
	}
}

void RoundRect(HDC hdc, RECT *rect, int cx, int cy, COLORREF fg, COLORREF bg)
{
	SetDCBrushColor(hdc, bg);
	SetDCPenColor(hdc, fg);
//	HBRUSH hBr = CreateSolidBrush(bg);
//	HPEN   hPn = CreatePen(0, PS_SOLID, fg);

//	HANDLE hOldBr  = SelectObject(hdc, hBr);
//	HANDLE hOldPen = SelectObject(hdc, hPn);

	RoundRect(hdc, rect->left, rect->top, rect->right, rect->bottom, cx, cy);

//	SelectObject(hdc, hOldBr);
//	SelectObject(hdc, hOldPen);
//	DeleteObject(hBr);
//	DeleteObject(hPn);
}

HRGN CreateRoundRectRgn(RECT *rect, int cx, int cy)
{
	return CreateRoundRectRgn(rect->left, rect->top, rect->right+1, rect->bottom+1, cx, cy);
}

	HFONT hFont1;
	HFONT hFont2;
	HFONT hFont3;

void Arse()
{
	hFont1 = CreateFont(-12,0,0,0,FW_BOLD,FALSE,0,0,0,0,0,0,0,_T("Tahoma"));
	hFont2 = CreateFont(-12,0,0,0,0,FALSE,0,0,0,0,0,0,0,_T("Tahoma"));
	hFont3 = CreateFont(-12,0,0,0,0,TRUE,0,0,0,0,0,0,0,_T("Tahoma"));

}

void HexView::DrawNoteStrip(HDC hdc, int nx, int ny, BOOKNODE *bnp)
{
	BOOKMARK *bookmark = &bnp->bookmark;

	RECT rect = { nx, ny, nx+300, ny+50 };
	RECT clip;
	const int colWidth = 18;

	HANDLE hOldBr  = SelectObject(hdc, GetStockObject(DC_BRUSH));
	HANDLE hOldPen = SelectObject(hdc, GetStockObject(DC_PEN));

	COLORREF colBG		= RGB(245,245,245);
	COLORREF colShadow	= RGB(220,220,220);//GetSysColor(COLOR_3DFACE);
	COLORREF colLine	= GetSysColor(COLOR_3DSHADOW);

	BookmarkRect(bookmark, &rect);

	//
	// [x] Close button 
	//
	//	Do this first so we can mask it out of the way; prevents flickering
	//
	CloseButton(hdc, &rect, &clip, m_HitTestHot == HVHT_BOOKCLOSE && m_HighlightHot == bnp);
	ExcludeClipRect(hdc, clip.left, clip.top, clip.right, clip.bottom);


	//
	// Main rectangle - dark border with light fill
	//
	RoundRect(hdc, &rect, 2, 2, colLine, colBG);

	// vertical separator line 
	MoveToEx(hdc, rect.left + colWidth, rect.top, 0);
	LineTo(hdc, rect.left + colWidth, rect.bottom);

	// color panel
	RECT colrc = { rect.left + 1, rect.top + 1, rect.left + colWidth, rect.bottom - 1 };
	SetBkColor(hdc, bookmark->backcol);
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &colrc, 0, 0, 0);

	RECT textrc = 
	{ 
		rect.left + colWidth + 8, rect.top + 4, rect.right - 4, rect.bottom - 4 
	};

	SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
	SetBkColor(hdc, colBG);
	SetTextAlign(hdc, TA_LEFT|TA_TOP);

	BOOL fItalic = FALSE;

	TCHAR *pszTitle = bookmark->pszTitle;
	TCHAR *pszText  = bookmark->pszText;

	if(pszTitle == 0 && pszText == 0)
	{
		fItalic	  = TRUE;
		pszTitle  = TEXT("Enter Bookmark");
		pszText   = TEXT("Descriptive text here");
	}
	
	HANDLE hOld;

	Arse();

	if(pszTitle)
	{
		// the text
		TCHAR text1[100];
		wsprintf(text1, _T("%08X - %d bytes"), bookmark->offset, bookmark->length);

		//hOld=SelectObject(hdc, hFont1);
		MoveToEx(hdc, textrc.left, textrc.top, 0);

		textrc.right -= 32;
		
		// draw the offset/length
		SetTextColor(hdc, GetSysColor(COLOR_3DDKSHADOW));
		hOld=SelectObject(hdc, hFont2);
		int height = DrawText(hdc, text1, lstrlen(text1), &textrc, DT_SINGLELINE|DT_RIGHT|DT_TOP|DT_NOPREFIX|DT_WORDBREAK|DT_MODIFYSTRING);//DT_NOCLIP|DT_LEFT|DT_WORDBREAK);
		SelectObject(hdc, hOld);

		// draw the title, left-aligned
		SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
		hOld=SelectObject(hdc, fItalic?hFont3:hFont1);
		height = DrawText(hdc, pszTitle, lstrlen(pszTitle), &textrc, DT_SINGLELINE|DT_LEFT|DT_TOP|DT_NOPREFIX|DT_WORDBREAK|DT_MODIFYSTRING);//DT_NOCLIP|DT_LEFT|DT_WORDBREAK);
		SelectObject(hdc, hOld);
		
		textrc.top += height;
	}

	if(pszText)
	{
		MoveToEx(hdc, textrc.left, textrc.top, 0);
		hOld = SelectObject(hdc, fItalic ? hFont3 : hFont2);
		DrawText(hdc, pszText, lstrlen(pszText), &textrc, DT_LEFT|DT_TOP|DT_NOPREFIX|DT_WORDBREAK|DT_MODIFYSTRING);//DT_NOCLIP|DT_LEFT|DT_WORDBREAK);
		SelectObject(hdc, hOld);
	}

	DeleteObject(hFont1);
	DeleteObject(hFont2);
	DeleteObject(hFont3);

	// sizing grip
	SizingGrip(hdc, &rect, 0);//, hPen);


	//
	//	Mask the rectangle
	//
/*	HRGN hClipRgn = CreateRoundRectRgn(&rect, 2, 2);
	ExtSelectClipRgn(hdc, hClipRgn, RGN_DIFF);

	//
	// Shadow goes underneath (offset by 2 pixels), so gets drawn first
	//
	OffsetRect(&rect, SHADOW_DEPTH, SHADOW_DEPTH);
	RoundRect(hdc, &rect, 2, 2, colShadow, colShadow);

	OffsetRgn(hClipRgn, SHADOW_DEPTH, SHADOW_DEPTH);
	ExtSelectClipRgn(hdc, hClipRgn, RGN_DIFF);
	DeleteObject(hClipRgn);*/

	//OffsetRect(&rect, -SHADOW_DEPTH, -SHADOW_DEPTH);


	// Include the shadow
	rect.right += SHADOW_DEPTH;
	rect.bottom += SHADOW_DEPTH;
	//RoundRect(hdc, smeg.left, smeg.top, smeg.right, smeg.bottom);
	ExcludeClipRect(hdc, rect.left, rect.top, rect.right, rect.bottom);

	SelectObject(hdc, hOldPen);
	SelectObject(hdc, hOldBr);

}

